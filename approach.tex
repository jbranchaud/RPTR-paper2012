\section{Approach}

In this section, we present our approach to doing runtime parameter tracking of ROS systems. Like many runtime monitoring systems, the key to our approach is instrumentation of the system under analysis. Finding a viable method of instrumenting a ROS system was a non-trivial task and as one of our contributions, we present the failed and successful approaches. We believe that not only the successful, but the failed approaches, especially, are useful for the insights they provide.

In addition to the instrumentation, RPTR has to implement two unique pieces that are specialized to ROS systems. First, ROS systems are able to do plenty of parameter interaction in the ROS launch files before the actual system is even executing, so these launch files must be preprocessed. We will discuss the task of preprocessing in the following subsection. Second, ROS systems are unique in their distributed nature and thus require a custom approach to monitoring, collecting, and storing the parameter interaction information.

Lastly, we will discuss the reports that RPTR is able to provide to developer's of a ROS system. Not only can RPTR generate these standard reports, but it can also provide feedback based on end-user queries.


\subsection{Preprocessing}

Many ROS systems contain one or more launch files which are XML files that hold various configuration information. This includes information about the nodes that will be executing at runtime, values that various parameters should take on, and references to other configuration files (e.g. YAML files and other launch files). Because of the parameter information available in these files, it is crucial that RPTR collect this data in a preprocessing phase.

The preprocessing phase in our tool involves a Python script that utilizes Python's standard DOM parser to extract the pertinent information. The pertinent information includes the \texttt{<param>}, \texttt{<include>}, and \texttt{<rosparam>} tags and their attributes. Additionally, we collect information about the \texttt{<node>} tags so that we know which nodes will be executing at runtime. Examples of all of these tags can be found in Fig.~\ref{fig:launchtags}.

\begin{figure}
	\begin{enumerate}[(a)]
		\item \texttt{<param name="namespace/path/param1" type="int" value="1" />}
		\item \texttt{<include file="$\$$(find package\_name)/../launch/filename.launch" />}
		\item \texttt{<rosparam file="$\$$(find package\_name)/../launch/dir\_name/config.yaml" />}
		\item \texttt{<node pkg="package\_name" name="node1" type="node\_type" ... > ... </node>}
	\end{enumerate}
	\caption{Interesting tags in ROS .launch files}
	\label{fig:launchtags}
\end{figure}

The first type of tag that we are interested in is the \texttt{<param>} tag found in Fig.~\ref{fig:launchtags}(a). For each of these tags that we find in the launch file, we are interested in five pieces of information which we can extract from both the tag's attributes as well as its position relative to other tags in the launch file. We first want to know the parent of the tag which is based on the tag's position. If the \texttt{<param>} tag is directly nested below the \texttt{<launch>} tag, then it is what is called a \emph{global parameter} and its parent is considered to be \emph{launch}. All other \texttt{<param>} tags will be found nested directly within a particular \texttt{<node>} tag, in which case we consider its parent to be the name of that node. Second we want to know the namespace of the tag which can be extracted from the name attribute. If the name begins with a $\sim$ (tilde), then the namespace is private. On the other hand, if there is nothing prepending the name, then it has a global namespace. Most commonly though, the name will be prepended by a forward-slash-separated path (as can be seen in Fig.~\ref{fig:launchtags}(a)). In this case, the namespace is relative/base which means that the namespace of that parameter is that path relative to its parent. It is important that we extract each parameter's namespace so that we know the scope of that parameter. Next we want the actual name of the parameter which is the remaining portion of the name attribute after extracting its namespace. We then want the value that the parameter is being set to which is the value attribute. Last we want the type of the parameter if it is given. The type can be \emph{int}, \emph{double}, \emph{bool}, or \emph{string} or if none is given, we denote it with \emph{UNK} (for unknown). With all of this parameter information, we are able to precisely characterize how the system's parameters are initially configured.

*** Where should the DB schema go? We need to present that table somewhere in the approach section.


\subsection{Instrumentation}

Content about the instrumentation and so forth.


\subsection{Runtime Monitoring}

Content about the RPTR node and other runtime monitoring details.


\subsection{Reports and Feedback}

Content about the reports generated by our tool as well as other ways to get feedback about parameter usage.
