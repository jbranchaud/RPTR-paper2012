\section{Related Work}

The domain that we have built our analysis for, ROS systems, is such a new and untapped area with regard to analysis that there is not much in the way of related work at this point. There are, however, a couple papers on runtime monitoring that have served, at least partially, as models for how this type of dynamic analysis can be done.

The first is JavaMOP and the MOP Runtime Verification Framework [1] which also does runtime monitoring of systems. The approach used by JavaMOP is to take as input specific properties and then based on those properties, the system under analysis will be instrumented for the monitor. Our approach is different in that we are not just looking for specific properties, but rather we want to know about all parameter interaction. To this end, we instrument all the areas of code that deal with parameters. In the spirit of JavaMOP, we originally intended to use Aspect Oriented Programming (AOP) [4] to instrument the subject systems. Just as JavaMOP used AspectJ [3], we intended to use AspectC++ [5] to inject our code into the systems. This, however, turned out to be infeasible and we ended up moving to a different instrumentation approach. This is all discussed later in Sec. 3 of the paper.

Another work related to ours is Efficient Monitoring of Safety Properties by Havelund and Rosu [2]. Just as they monitor for safety properties, our approach tries to identify sequences of parameter interactions that will result in an error state. In this way, both their approach and ours is looking at linear temporal properties. Our tool, however, does not allow for the specification of particular LTL formulas though, instead we have defined a finite state automata (FSA) unique to parameter usage in ROS systems. When certain sequences of interactions advance to an error state, we are able to alert the user of this. The following section will more fully discuss the approach we have taken and through those details the novelty of RPTR can be plainly seen.
